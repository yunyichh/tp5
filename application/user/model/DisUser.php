<?php
namespace app\user\model;
use think\Model;
use think\Db;
class DisUser extends Model
{  
  //模型返回模型对象实例 --多维
  function getUserById($id=''){
    $data = $this->where('id',$id)->select();
    return $data;
  }
  //Db类返回数组--多维
  function getUserById2($id='')
  {
    $data = Db::name('dis_user')->where('id',$id)->select();
    return $data;
  }  
  //调用 也是多维
  function getUserById3($id='')
  {
    $data = $this->getUserById($id);
    return $data;
  }
  //返回模型对象实例--一维
  function getUserById4($id='')
  {
    $data = $this->where('id',$id)->find();
    return $data;
  }
  //返回数组--一维
  function getUserById5($id='')
  {
    $data = Db::name('dis_user')->where('id',$id)->find();
    return $data;
  }
 
}
// tp5中的模型和Db
// 1、Db和模型的存在只是ThinkPHP5.0架构设计中的职责和定位不同，Db负责的只是数据（表）访问，模型负责的是业务数据和业务逻辑。
// 2、Db和模型最明显的一个区别就是Db查询返回的数据类型为数组（对于一个没有业务逻辑的数据而言，数组已经足够），而模型的查询返回类型的是模型对象实例。
// 3、总而言之，想要掌握模型，必须明白和理解下面几个原则：
// 模型和数据库层的定位和职责不同；
// 不要因为性能而放弃使用模型，那是得不偿失的；
// 用面向对象的方式来使用和设计模型；
// 模型的数据底层操作仍然是数据库抽象访问层，而且是自动的


// 4、模型定义有几个要素：
// 通常会继承think\Model（或者子类），虚拟模型除外；
// 一个模型并不总是对应一个数据表（可能会有多个），虽然默认如此；
// 模型名和数据表名也不是直接对应关系；
// 尽管一个空模型和使用Db类无异，但意义不同；


// 5、模型定义阶段要达成的目的：
// 定义数据表（默认就是模型类名）
// 定义数据表主键（默认会自动获取）
// 定义数据库连接（默认使用数据库配置）
// 定义数据处理逻辑（包括属性和方法）
// 定义业务逻辑（方法）


// 6、下面的定义是不需要或者不支持的：
// 数据表字段（不需要，会自动获取，并支持缓存机制）
// 数据表前缀（不支持，模型不关心前缀）


// 7、大多数情况下，数据表和数据库连接是不需要定义的，数据处理逻辑和业务逻辑才是模型定义的重点


// 8、在新版框架的架构设计规范中，我们建议数据表的命名不使用前缀设计，表前缀其实已经是一种过时的设计了，很多时候跨库的设计比表前缀的设计来的更灵活和实用，而且前缀设计（尤其是在混合用的情况下）带来的一些困惑和问题却是很多新手最大的苦恼，所以何必自寻烦恼（如果你一定要采用前缀设计，那么请用name方法替代table方法，并且在数据库配置文件中配置prefix参数，我也不拦着你，哭的时候别找我^_^）


// 9、关于模型的连接对象和查询对象，要清楚下面这些事实：


// 模型可以单独设置数据库连接；
// 模型的数据库连接是惰性的（因为连接本身就是惰性）；
// 如果使用统一的数据库配置，模型使用的连接对象是相同的；
// 模型使用的查询对象是独立的；
// 模型可以使用自定义的查询对象；


// 10、模型类实现了ArrayAccess接口，因此一样可以使用数组方式操作对象


// 11、因为模型基本上是内部处理业务逻辑，所以会出现内部调用的时候
// 以name属性为例，获取模型数据的方式有下列三种：
// 场景 方法
// 外部获取模型数据 $model->name
// 内部获取模型数据 $this->getAttr('name')
// 内部获取（原始）模型数据 $this->getData('name')
// getData和getAttr方法的区别前者是原始数据，后者是经过读取器处理的数据，如果没有定义数据读取器的话，两个方法的结果是相同的。


// 对应的设置模型数据的方式也有三种：
// 场景 方法
// 外部设置模型数据 $model->name='thinkphp'
// 内部设置模型数据（经过修改器） $this->setAttr('name','thinkphp')
// 内部设置模型数据 $this->data('name','thinkphp')
// data和setAttr方法的区别前者是赋值最终数据，后者赋值的数据还会经过修改器处理，如果没有定义修改器的话，两个方法的结果是相同的。


// 12、CURL
// 模型的CURD操作最终调用的还是Db类的操作，区别在于使用了ActiveRecord模式和单独做了一层封装而已
// 除了模型自己的方法操作外，还可以调用Db类的所有查询方法，也就是说Db类的CURD操作方法都可以在模型类中被调用。
// //创建
// //动态
// $user        = new User;
// $user->name  = 'thinkphp';
// $user->email = 'thinkphp@qq.com';
// $user->save();
// // 获取用户的主键数据
// echo $user->id;
// //静态
// $user = User::create([
//     'name'  => 'thinkphp',
//     'email' => 'thinkphp@qq.com',
// ]);
// echo $user->id;


// //读取
// $user = User::get(1);
// echo $user->id;


// // 查询用户数据集
// $users = User::all([1, 2, 3]);
// $users = User::where('id', '>', 1)
//     ->limit(5)
//     ->select();
// // 遍历读取用户数据
// foreach ($users as $user) {
//     echo $user->id;
//     echo $user->name;
// }




// //更新
// //动态 返回影响的记录数
// $user = User::get(1);
// $user->save([
//     'name'  => 'topthink',
//     'email' => 'topthink@qq.com',
// ]);
// //静态 返回模型对象实例
// User::update([
//     'name'  => 'topthink',
//     'email' => 'topthink@qq.com',
// ], ['id' => 1]);


// //删除
// $user = User::get(1);
// $user->delete();
// //静态实现
// User::destroy(1);


// 现在我们已经掌握了模型的基本CURD操作，我们来总结下方法区别：
// 用法 Db类 模型（动态） 模型（静态）
// 创建 insert save create
// 更新 update save update
// 读取单个 find find get
// 读取多个 select select all
// 删除 delete delete destroy
// 然后要注意几个注意事项：


// 模型类可以直接调用Db类的所有方法；
// 模型类和Db类的查询返回类型是完全不同的，即便是调用同一个方法查询；
// 模型类封装的静态方法本质上还是调用的动态方法，只是为了方便不同的需求场景；
// 模型对象的查询操作尽量使用静态方法调用；


// 13、查询构造器
// 查询构造器的用法在模型类中没有变化，并且还做了一些增强来支持模型的CURD封装方法。


// 所有的链式方法都可以直接被模型类静态调用，而且一样不分先后次序，你只要掌握了数据库的查询构造器用法，就能掌握模型的查询用法，而且模型类不需要调用table方法来指定数据表名称，因为模型已经有自己的对应数据表规则，从这一点来说，模型的查询操作应该比Db类的查询操作用法简单


// 模型可以直接调用Db类（确切的说是查询类）的方法，无论是静态还是动态调用，也就是说你可以把模型类当成Db类一样使用（虽然用法一样，但其实区别很大，可能查询条件、查询结果和返回类型都不同）


// 14、数据集
// // 设置数据集返回类型 database.php中
// 'resultset_type'  => 'collection',
// // 设置模型的数据集返回类型 模型中
// protected $resultSetType = 'collection';
// 数据集的优势：


// 数据更对象化；
// 关联操作更方便；
// 数据集本身可以单独定义独立的业务方法；


// 15、业务逻辑
// 业务逻辑应当封装到具体模型中，并由控制器来调用；